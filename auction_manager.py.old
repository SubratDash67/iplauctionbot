"""
Auction Manager Module
Handles all auction-related logic and state management
"""

import asyncio
import random
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import discord

from config import DEFAULT_BASE_PRICE, DEFAULT_COUNTDOWN, PLAYER_GAP, LIST_GAP
from utils import FileManager, MessageFormatter, calculate_next_bid


class AuctionState:
    """Manages the current state of the auction"""

    def __init__(self):
        self.active = False
        self.paused = False
        self.current_player: Optional[str] = None
        self.current_list_index = 0
        self.base_price = DEFAULT_BASE_PRICE
        self.current_bid = 0
        self.highest_bidder: Optional[str] = None
        self.countdown_seconds = DEFAULT_COUNTDOWN
        self.seconds_since_last_bid = 0
        self.countdown_task: Optional[asyncio.Task] = None
        self.countdown_message: Optional[discord.Message] = None

    def reset(self):
        """Reset auction state"""
        self.active = False
        self.paused = False
        self.current_player = None
        self.current_list_index = 0
        self.current_bid = 0
        self.highest_bidder = None
        self.seconds_since_last_bid = 0
        if self.countdown_task:
            self.countdown_task.cancel()
        self.countdown_task = None
        self.countdown_message = None

    def reset_player_state(self):
        """Reset state for a new player"""
        self.current_player = None
        self.current_bid = 0
        self.highest_bidder = None
        self.seconds_since_last_bid = 0
        if self.countdown_task:
            self.countdown_task.cancel()
        self.countdown_task = None
        self.countdown_message = None


class AuctionManager:
    """Main auction management class"""

    def __init__(self, teams: Dict[str, int], excel_file: str):
        self.teams = teams.copy()
        self.original_purses = teams.copy()
        self.team_squads: Dict[str, List[Tuple[str, int]]] = {
            team: [] for team in teams
        }
        # player_lists: dict[listname] = list of tuples (name, base_price_or_None)
        self.player_lists: Dict[str, List[Tuple[str, Optional[int]]]] = {}
        self.list_order: List[str] = []
        self.state = AuctionState()
        self.excel_file = excel_file
        self.file_manager = FileManager()
        self.formatter = MessageFormatter()

        # Initialize Excel file
        try:
            self.file_manager.initialize_excel(self.excel_file)
        except Exception as e:
            print(f"Warning: Could not initialize Excel file: {e}")

    def create_list(self, list_name: str) -> bool:
        """Create a new player list"""
        list_name = list_name.lower()
        if list_name in self.player_lists:
            return False
        self.player_lists[list_name] = []
        if list_name not in self.list_order:
            self.list_order.append(list_name)
        return True

    def add_player_to_list(self, list_name: str, player: Tuple[str, Optional[int]]) -> bool:
        """Add a player to a specific list"""
        list_name = list_name.lower()
        if list_name not in self.player_lists:
            return False
        self.player_lists[list_name].append(player)
        return True

    def load_list_from_csv(self, list_name: str, filepath: str) -> Tuple[bool, str]:
        """Load players from CSV into a list"""
        list_name = list_name.lower()
        try:
            players = self.file_manager.load_players_from_csv(filepath)
            if not players:
                return False, "No players found in CSV file"

            if list_name not in self.player_lists:
                self.create_list(list_name)

            # players are tuples (name, base_price)
            self.player_lists[list_name].extend(players)
            return True, f"Loaded {len(players)} players into {list_name}"
        except Exception as e:
            return False, str(e)

    def set_list_order(self, order: List[str]) -> Tuple[bool, str]:
        """Set custom order for lists"""
        order_lower = [name.lower() for name in order]
        for list_name in order_lower:
            if list_name not in self.player_lists:
                return False, f"List '{list_name}' does not exist"
        self.list_order = order_lower
        return True, "List order updated successfully"

    def get_list_info(self) -> str:
        """Get formatted information about all lists"""
        return self.formatter.format_list_display(self.player_lists, self.list_order)

    def start_auction(self) -> Tuple[bool, str]:
        """Start the auction"""
        if self.state.active:
            return False, "Auction is already running"

        if not self.player_lists:
            return False, "No player lists available"

        if not self.list_order:
            # default order is creation order
            self.list_order = list(self.player_lists.keys())

        self.state.active = True
        self.state.current_list_index = 0
        self.state.paused = False
        return True, "Auction started successfully"

    def stop_auction(self) -> bool:
        """Stop the auction"""
        if not self.state.active:
            return False
        self.state.reset()
        return True

    def pause_auction(self) -> bool:
        """Pause the auction"""
        if not self.state.active or self.state.paused:
            return False
        self.state.paused = True
        return True

    def resume_auction(self) -> bool:
        """Resume the auction"""
        if not self.state.active or not self.state.paused:
            return False
        self.state.paused = False
        self.state.seconds_since_last_bid = 0
        return True

    def get_next_player(self) -> Optional[Tuple[str, Optional[int]]]:
        """Get the next player to auction"""
        while self.state.current_list_index < len(self.list_order):
            current_list = self.list_order[self.state.current_list_index]

            if self.player_lists[current_list]:
                player_tuple = random.choice(self.player_lists[current_list])
                # remove that tuple
                self.player_lists[current_list].remove(player_tuple)
                self.state.reset_player_state()
                player_name, base_price = player_tuple
                # set base price from CSV if provided else default
                self.state.current_player = player_name
                self.state.base_price = base_price if base_price is not None else DEFAULT_BASE_PRICE
                self.state.current_bid = self.state.base_price
                return (player_name, self.state.base_price)
            else:
                # finished this list, move to next
                self.state.current_list_index += 1

        return None

    def place_bid(self, team: str) -> Tuple[bool, str, int]:
        """Place a bid for a team"""
        if not self.state.active or self.state.paused:
            return False, "Auction is not active", 0

        if not self.state.current_player:
            return False, "No player is currently being auctioned", 0

        team_upper = team.upper()
        if team_upper not in self.teams:
            return False, "Invalid team name", 0

        next_bid = calculate_next_bid(self.state.current_bid)

        if self.teams[team_upper] < next_bid:
            return False, "Insufficient purse balance", 0

        self.state.current_bid = next_bid
        self.state.highest_bidder = team_upper
        self.state.seconds_since_last_bid = 0

        return True, "Bid placed successfully", next_bid

    def finalize_sale(self) -> Tuple[bool, Optional[str], int]:
        """Finalize the sale of current player"""
        if not self.state.current_player:
            return False, None, 0

        player = self.state.current_player
        team = self.state.highest_bidder
        amount = self.state.current_bid

        if team:
            self.teams[team] -= amount
            self.team_squads[team].append((player, amount))

            try:
                self.file_manager.save_player_to_excel(
                    self.excel_file, player, team, amount, self.teams[team]
                )
                self.file_manager.update_team_summary(
                    self.excel_file, self.teams, self.team_squads
                )
            except Exception as e:
                print(f"Error saving to Excel: {e}")

            return True, team, amount

        return False, None, 0

    def set_countdown(self, seconds: int) -> bool:
        """Set countdown duration"""
        if seconds < 5 or seconds > 300:
            return False
        self.state.countdown_seconds = seconds
        return True

    def set_team_purse(self, team: str, amount: int) -> bool:
        """Set team purse manually"""
        team_upper = team.upper()
        if team_upper not in self.teams:
            return False
        if amount < 0:
            return False
        self.teams[team_upper] = amount
        return True

    def clear_all_data(self):
        """Clear all auction data and reset"""
        self.state.reset()
        self.teams = self.original_purses.copy()
        self.team_squads = {team: [] for team in self.teams}
        self.player_lists.clear()
        self.list_order.clear()

        try:
            self.file_manager.initialize_excel(self.excel_file)
        except Exception as e:
            print(f"Error reinitializing Excel: {e}")

    def get_purse_display(self) -> str:
        """Get formatted purse display"""
        return self.formatter.format_purse_display(self.teams)

    def get_current_list_name(self) -> Optional[str]:
        """Get the name of the current list"""
        if 0 <= self.state.current_list_index < len(self.list_order):
            return self.list_order[self.state.current_list_index]
        return None
